#pragma once
// separateRenderer.h
// the point of the header is to automatically take care of everything that needs to be done on the render thread
// by setting up everything on the update thread. 
#include <array>
#include <vector>
#include <cassert>
#include <variant>
#include <glm/glm.hpp>
#include <atomic>
#include <string>
#include <map>
#include <Shader.h>

// need stronger texture support. implement more examples. adding assimp support will likely provide sufficient experience

// profile for abstraction cost generated by this method. Does the variant usage increase overhead due to the nature of std::get?

// vertex attribute array behaviour is dependent on whether the input data is a collection of floats or a glm::vec3 value!
// solved by adding a value count per buffer. increases input but grants flexibility, hm...
// adding constraints on the type of data that can be used eliminates a lot of these issues :/ Uncertain if such a restriction is worth it. 
// on the flip side, the present method adding the attribute size, count, etc. is non-intuitive
// the input for buffer set-up has to be clarified. 
namespace separateRenderer
{
	typedef std::variant<int, float, glm::vec3, glm::mat4> mywrap;

	// Forward declarations
	struct bufferObject;

	struct bufferData;

	bufferObject mycreateBuffers(bufferData input);

	struct bufferObject
	{
		Shader sh;

		unsigned int vao;
		unsigned int ebo;
		std::vector<unsigned int> vbo;

		bufferObject(std::array<const char*, 3> shaderSource) :sh(shaderSource), vao(0), vbo({ 0 }), ebo(0)
		{ }
	};

	struct bufferData
	{
		// allow buffer reuse by pointing to existing buffers
		std::vector<std::variant<std::vector<int>, std::vector<float>, std::vector<glm::vec3>>> allData; // to hold all buffer data
		
		std::vector<size_t> attributeCount; // contains the number of attributes in the shader each buffer corresponds to
		std::vector<size_t> attributeSize;  // size of each attribute. contains sum(attributeCount[i]) elements
		std::vector<size_t> totalAttributeCount;

		// buffer#, offset, size to replace, (starting) index of position to replace (if more than 1 contiguous element)
		std::vector<std::vector<int>> listofbufferchanges;

		bool instanced;
		int instanceCount;
		bool drawarrays;
		int vertexIndexCount;
		int primitiveType;
		std::vector<int> instancedBufferIndex;
		
		// for uniforms- add an vector to indicate which uniforms need based on the updateUnifrom function call
		// these two are meant to be tightly coupled. Note that typo's in uniform names are not checked at compile time
		std::map<std::string, int> uniformListing;
		std::vector<mywrap> uniformValues;

		// for shaders
		std::array<const char*, 3> shaderListing;

		void addUniform(std::string name, mywrap input)
		{
			uniformValues.push_back(input);
			uniformListing[name]=uniformValues.size()-1;
		}
		
		void addUniform(std::string name)
		{
			uniformValues.push_back(0);
			uniformListing[name] = uniformValues.size() - 1;
		}

		void updateUniform(std::string name, mywrap input)
		{
			// add error checking to ensure that the correct name is being used
			int index = uniformListing[name];
			uniformValues[index]= input;
		}
	};

	struct getVectorSizeVisitor
	{
		int operator()(std::vector<int>& input)
		{
			return input.size();
		}
		int operator()(std::vector<float>& input)
		{
			return input.size();
		}
		int operator()(std::vector<glm::vec3>& input)
		{
			return input.size();
		}
	};
	
	struct getElementSizeVisitor
	{
		int operator()(std::vector<int>& input)
		{
			return sizeof(input[0]);
		}
		int operator()(std::vector<float>& input)
		{
			return sizeof(input[0]);
		}
		int operator()(std::vector<glm::vec3>& input)
		{
			return sizeof(input[0]);
		}
	};

	struct getElementPointerVisitor
	{
		void* operator()(std::vector<int>& input)
		{
			return &input[0];
		}
		void* operator()(std::vector<float>& input)
		{
			return &input[0];
		}
		void* operator()(std::vector<glm::vec3>& input)
		{
			return &input[0];
		}
	};
	
	// ideally, the buffer objects should be assigned the correct usage (GL_STATIC_DRAW, GL_DYNAMIC_DRAW etc.) but 
	// since these are simply hints, using static_draw for all for now
	bufferObject mycreateBuffers(bufferData inputdata)
	{
		int bufferCount = inputdata.attributeCount.size();
		
		bufferObject localBufferObject(inputdata.shaderListing);
		glGenVertexArrays(1, &localBufferObject.vao);

		localBufferObject.vbo = std::vector<unsigned int>(bufferCount, 0);
		glGenBuffers(bufferCount, &localBufferObject.vbo[0]);

		glBindVertexArray(localBufferObject.vao);
		int cumattribcount = 0;
		for (int vboIndex = 0, bufferIndex = 1; vboIndex < bufferCount; ++vboIndex, ++bufferIndex)
		{
			int bufferOffset = 0;
			glBindBuffer(GL_ARRAY_BUFFER, localBufferObject.vbo[vboIndex]);

			int elementSize = std::visit(getElementSizeVisitor{}, inputdata.allData[bufferIndex]);
			int dataSize = std::visit(getVectorSizeVisitor{}, inputdata.allData[bufferIndex]);
			void* firstElementPointer = std::visit(getElementPointerVisitor{}, inputdata.allData[bufferIndex]);
			
			int bufferSize = dataSize * elementSize;
			glBufferData(GL_ARRAY_BUFFER, bufferSize, firstElementPointer, GL_STATIC_DRAW);

			for (unsigned int j = 0; j < inputdata.attributeCount[vboIndex]; ++j)
			{
				glVertexAttribPointer(cumattribcount, inputdata.attributeSize[cumattribcount], GL_FLOAT, GL_FALSE, inputdata.totalAttributeCount[vboIndex] * elementSize, (void*)(bufferOffset * elementSize));
				glEnableVertexAttribArray(cumattribcount);
				if(inputdata.instancedBufferIndex[vboIndex])
					glVertexAttribDivisor(cumattribcount, 1);

				bufferOffset += inputdata.attributeSize[cumattribcount];
				cumattribcount++;
			}
		}

		int indexSize = std::get<0>(inputdata.allData[0]).size();
		if (indexSize)
		{
			using indextype = decltype(std::get<0>(inputdata.allData[0])[0]);
			glGenBuffers(1, &localBufferObject.ebo);
			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, localBufferObject.ebo);
			glBufferData(GL_ELEMENT_ARRAY_BUFFER, indexSize * sizeof(indextype), &std::get<0>(inputdata.allData[0])[0], GL_STATIC_DRAW);
		}

		return localBufferObject;
	}

	void updateUniforms(bufferData input, Shader sh)
	{
		sh.use();
		for (auto mypair : input.uniformListing)
		{
			switch (input.uniformValues[mypair.second].index())
			{
			case 0:sh.setInt(mypair.first, std::get<int>(input.uniformValues[mypair.second])); break;
			case 1:sh.setFloat(mypair.first, std::get<float>(input.uniformValues[mypair.second])); break;
			case 2:sh.setVec3(mypair.first, std::get<glm::vec3>(input.uniformValues[mypair.second])); break;
			case 3:sh.setMat4(mypair.first, std::get<glm::mat4>(input.uniformValues[mypair.second])); break;
			}
		}
	}

	// ideally, all updates to a buffer should be done first before moving to next to minimize state changes
	void updateBuffers(bufferData input, bufferObject object)
	{
		for (int i = 0; i < input.listofbufferchanges.size(); ++i)
		{
			// this difference is because the first buffer is reserved for the element buffer data
			int bufferIndex = input.listofbufferchanges[i][0] + 1;
			int vboIndex = input.listofbufferchanges[i][0];

			void* firstElementPtr = std::visit(getElementPointerVisitor{}, input.allData[bufferIndex]);
			int elementSize = std::visit(getElementSizeVisitor{}, input.allData[bufferIndex]);
			int byteOffset = input.listofbufferchanges[i][1];
			int byteLength = input.listofbufferchanges[i][2];

			int replaceDataIndex = input.listofbufferchanges[i][3];
			int replaceDataOffset = elementSize * replaceDataIndex;
			char* replaceDataByteLocation = (char*)firstElementPtr + replaceDataOffset;
			int localVBO = object.vbo[vboIndex];

			glBindBuffer(GL_ARRAY_BUFFER, localVBO);
			glBufferSubData(GL_ARRAY_BUFFER, byteOffset, byteLength, (void*)replaceDataByteLocation);
		}
	}

	void frameUpdate(std::vector<separateRenderer::bufferData>& currFrameData, std::vector<separateRenderer::bufferData>& prevFrameData)
	{
		for (int i = 0; i < prevFrameData.size(); ++i)
		{
			for (int j = 0; j < prevFrameData[i].listofbufferchanges.size(); ++j)
			{
				int ind = prevFrameData[i].listofbufferchanges[j][0] + 1;
				int ind2 = prevFrameData[i].listofbufferchanges[j][3];
				switch (prevFrameData[i].allData[ind].index())
				{
				case 0:std::get<std::vector<int>>(currFrameData[i].allData[ind])[ind2] = std::get<std::vector<int>>(prevFrameData[i].allData[ind])[ind2]; break;
				case 1:std::get<std::vector<float>>(currFrameData[i].allData[ind])[ind2] = std::get<std::vector<float>>(prevFrameData[i].allData[ind])[ind2]; break;
				case 2:std::get<std::vector<glm::vec3>>(currFrameData[i].allData[ind])[ind2] = std::get<std::vector<glm::vec3>>(prevFrameData[i].allData[ind])[ind2]; break;
				}
			}
			currFrameData[i].instanceCount = prevFrameData[i].instanceCount;
		}

		// reset current frame updates
		for (int i = 0; i < currFrameData.size(); ++i)
		{
			currFrameData[i].listofbufferchanges.clear();
		}
	}

	void draw(bufferData input, bufferObject object)
	{
		glBindVertexArray(object.vao);
		if (input.instanced)
		{
			if (input.drawarrays)
				glDrawArraysInstanced(input.primitiveType, 0, input.vertexIndexCount, input.instanceCount);
			else
				glDrawElementsInstanced(input.primitiveType, (unsigned int)input.vertexIndexCount, GL_UNSIGNED_INT, 0, input.instanceCount);
		}
		else
		{
			if (input.drawarrays)
				glDrawArrays(input.primitiveType, 0, input.vertexIndexCount);
			else
				glDrawElements(input.primitiveType, (unsigned int)input.vertexIndexCount, GL_UNSIGNED_INT, 0);
		}
	}


	std::vector<bufferData> updatelist;
	std::vector<bufferData> updatelist2;  // contains a deep copy of updatelist

	std::vector<bufferObject> renderlist;

	std::atomic<unsigned long long> myptr = 0, otherptr = 0;
	std::atomic<bool> stop = false;

	std::vector<std::array<int, 5>> listofbufferchanges;
}