#pragma once
// separateRenderer.h
// the point of the header is to automatically take care of everything that needs to be done on the render thread
// by setting up everything on the update thread. 
#include <array>
#include <vector>
#include <cassert>
#include <variant>
#include <glm/glm.hpp>
#include <atomic>
#include <string>
#include <map>

// need to add a helper function that draws automates uniform setting and executes draw commands using the input- updatelist/updatelist2

// need stronger texture support. implement more examples. adding assimp support will likely provide sufficient experience

// need to integrate shader header into this.

// profile for abstraction cost generated by this method. Does the variant usage increase overhead due to the nature of std::get?

// vertex attribute array behaviour is dependent on whether the input data is a collection of floats or a glm::vec3 value!
// solved by adding a value count per buffer. increases input but grants flexibility, hm...
// the input for buffer set-up has to be clarified. 
namespace separateRenderer
{
	typedef std::variant<int, float, glm::vec3, glm::mat4> mywrap;

	// Forward declarations
	struct bufferObject;

	struct bufferData;

	bufferObject mycreateBuffers(bufferData input);

	struct bufferObject
	{
		// needs shader support.
		unsigned int vao;
		unsigned int ebo;

		std::vector<unsigned int> vbo;

		bufferObject()
		{
			vao = 0;
			vbo = { 0 };
			ebo = 0;
		}
	};

	struct bufferData
	{
		// if indices are not used, we need the number of vertices to be rendered. else use the indices buffer size.
		// add texture support and sampler2D as an option for uniformValues
		// allow buffer reuse by pointing to existing buffers
		// multi shader support
		std::vector<std::variant<std::vector<int>, std::vector<float>, std::vector<glm::vec3>>> allData; // to hold all buffer data
		
		std::vector<size_t> attributeCount; // contains the number of attributes in the shader each buffer corresponds to
		std::vector<size_t> attributeSize;  // size of each attribute. contains sum(attributeCount[i]) elements
		std::vector<size_t> totalAttributeCount;

		// to modify buffer data- UGLY. needs refinement
		// buffer#, offset, size to replace, pointer to location
		// again, ugly. the pointer is casted to an int to store and then casted to void* when using :/
		std::vector<std::vector<int>> listofbufferchanges;
		std::vector<int> bufferlocations;

		bool instanced;
		int instanceCount;
		bool drawarrays;
		int vertexIndexCount;
		int primitiveType;
		std::vector<int> instancedBufferIndex;
		
		// for uniforms- add an vector to indicate which uniforms need based on the updateUnifrom function call
		// these two are meant to be tightly coupled. Note that typo's in uniform names are not checked at compile time
		std::map<std::string, int> uniformListing;
		std::vector<mywrap> uniformValues;

		// for shaders
		std::array<std::string, 3> shaderListing;

		void addUniform(std::string name, mywrap input)
		{
			uniformValues.push_back(input);
			uniformListing[name]=uniformValues.size()-1;
		}
		
		void addUniform(std::string name)
		{
			uniformValues.push_back(0);
			uniformListing[name] = uniformValues.size() - 1;
		}

		void updateUniform(std::string name, mywrap input)
		{
			// add error checking to ensure that the correct name is being used
			int index = uniformListing[name];
			uniformValues[index]= input;
		}
	};

	void updateUniforms(bufferData input)
	{
		// needs to be coupled with the shader header to set uniform values!
		for (auto mypair : input.uniformListing)
		{
			switch (input.uniformValues[mypair.second].index())
			{
			//case 0:sh.setInt(mypair.first, std::get<int>(input.uniformValues[mypair.second])); break;
			//case 1:sh.setFloat(mypair.first, std::get<float>(input.uniformValues[mypair.second])); break;
			//case 2:sh.setVec3(mypair.first, std::get<glm::vec3>(input.uniformValues[mypair.second])); break;
			//case 3:sh.setMat4(mypair.first, std::get<glm::mat4>(input.uniformValues[mypair.second])); break;
			}
		}
	}

	struct getVectorSizeVisitor
	{
		int operator()(std::vector<int>& input)
		{
			return input.size();
		}
		int operator()(std::vector<float>& input)
		{
			return input.size();
		}
		int operator()(std::vector<glm::vec3>& input)
		{
			return input.size();
		}
	};
	
	struct getElementSizeVisitor
	{
		int operator()(std::vector<int>& input)
		{
			return sizeof(input[0]);
		}
		int operator()(std::vector<float>& input)
		{
			return sizeof(input[0]);
		}
		int operator()(std::vector<glm::vec3>& input)
		{
			return sizeof(input[0]);
		}
	};

	struct getElementPointerVisitor
	{
		void* operator()(std::vector<int>& input)
		{
			return &input[0];
		}
		void* operator()(std::vector<float>& input)
		{
			return &input[0];
		}
		void* operator()(std::vector<glm::vec3>& input)
		{
			return &input[0];
		}
	};
	
	// ideally, the buffer objects should be assigned the correct usage (GL_STATIC_DRAW, GL_DYNAMIC_DRAW etc.) but 
	// since these are simply hints, using static_draw for all for now
	bufferObject mycreateBuffers(bufferData inputdata)
	{
		int bufferCount = inputdata.attributeCount.size();
		
		bufferObject localBufferObject;
		glGenVertexArrays(1, &localBufferObject.vao);

		localBufferObject.vbo = std::vector<unsigned int>(bufferCount, 0);
		glGenBuffers(bufferCount, &localBufferObject.vbo[0]);

		glBindVertexArray(localBufferObject.vao);
		int cumattribcount = 0;
		for (int i = 0; i < bufferCount; ++i)
		{
			int bufferOffset = 0;
			glBindBuffer(GL_ARRAY_BUFFER, localBufferObject.vbo[i]);

			int elementSize = std::visit(getElementSizeVisitor{}, inputdata.allData[i+1]);
			int dataSize = std::visit(getVectorSizeVisitor{}, inputdata.allData[i+1]);
			void* firstElementPointer = std::visit(getElementPointerVisitor{}, inputdata.allData[i+1]);
			glBufferData(GL_ARRAY_BUFFER, dataSize * elementSize, firstElementPointer, GL_STATIC_DRAW);

			for (unsigned int j = 0; j < inputdata.attributeCount[i]; ++j)
			{
				glVertexAttribPointer(cumattribcount, inputdata.attributeSize[cumattribcount], GL_FLOAT, GL_FALSE, inputdata.totalAttributeCount[i] * elementSize, (void*)(bufferOffset * elementSize));
				glEnableVertexAttribArray(cumattribcount);
				if(inputdata.instancedBufferIndex[i])
					glVertexAttribDivisor(cumattribcount, 1);

				bufferOffset += inputdata.attributeSize[cumattribcount];
				cumattribcount++;
			}
		}

		int indexSize = std::get<0>(inputdata.allData[0]).size();
		if (indexSize)
		{
			using indextype = decltype(std::get<0>(inputdata.allData[0])[0]);
			glGenBuffers(1, &localBufferObject.ebo);
			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, localBufferObject.ebo);
			glBufferData(GL_ELEMENT_ARRAY_BUFFER, indexSize * sizeof(indextype), &std::get<0>(inputdata.allData[0])[0], GL_STATIC_DRAW);
		}

		return localBufferObject;
	}

	std::vector<bufferData> updatelist;
	std::vector<bufferData> updatelist2;  // contains a deep copy of updatelist

	std::vector<bufferObject> renderlist;

	std::atomic<unsigned long long> myptr = 0, otherptr = 0;
	std::atomic<bool> stop = false;

	std::vector<std::array<int, 5>> listofbufferchanges;
}